% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\RequirePackage{amsmath,amssymb}
\documentclass{llncs}
%
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{mathpartir} % inference rules

\input{macros}
%
\begin{document}

%
\frontmatter          % for the preliminaries
%
%\pagestyle{headings}  % switches on printing of running heads
%\addtocmark{Hamiltonian Mechanics} % additional mark in the TOC
%
% \chapter*{Preface}
% %
% This textbook is intended for use by students of physics, physical
% chemistry, and theoretical chemistry. The reader is presumed to have a
% basic knowledge of atomic and quantum physics at the level provided, for
% example, by the first few chapters in our book {\it The Physics of Atoms
% and Quanta}. The student of physics will find here material which should
% be included in the basic education of every physicist. This book should
% furthermore allow students to acquire an appreciation of the breadth and
% variety within the field of molecular physics and its future as a
% fascinating area of research.

% For the student of chemistry, the concepts introduced in this book will
% provide a theoretical framework for that entire field of study. With the
% help of these concepts, it is at least in principle possible to reduce
% the enormous body of empirical chemical knowledge to a few basic
% principles: those of quantum mechanics. In addition, modern physical
% methods whose fundamentals are introduced here are becoming increasingly
% important in chemistry and now represent indispensable tools for the
% chemist. As examples, we might mention the structural analysis of
% complex organic compounds, spectroscopic investigation of very rapid
% reaction processes or, as a practical application, the remote detection
% of pollutants in the air.

% \vspace{1cm}
% \begin{flushright}\noindent
% April 1995\hfill Walter Olthoff\\
% Program Chair\\
% ECOOP'95
% \end{flushright}
% %
% \chapter*{Organization}
% ECOOP'95 is organized by the department of Computer Science, Univeristy
% of \AA rhus and AITO (association Internationa pour les Technologie
% Object) in cooperation with ACM/SIGPLAN.
% %
% \section*{Executive Commitee}
% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
% Tutorials:&Birger M\o ller-Pedersen\hfil\break
% (Norwegian Computing Center, Norway)\\
% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
% Panels:&Boris Magnusson (Lund University, Sweden)\\
% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
% \end{tabular}
% %
% \section*{Program Commitee}
% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
% Tutorials:&Birger M\o ller-Pedersen\hfil\break
% (Norwegian Computing Center, Norway)\\
% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
% Panels:&Boris Magnusson (Lund University, Sweden)\\
% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
% \end{tabular}
% %
% \begin{multicols}{3}[\section*{Referees}]
% V.~Andreev\\
% B\"arwolff\\
% E.~Barrelet\\
% H.P.~Beck\\
% G.~Bernardi\\
% E.~Binder\\
% P.C.~Bosetti\\
% Braunschweig\\
% F.W.~B\"usser\\
% T.~Carli\\
% A.B.~Clegg\\
% G.~Cozzika\\
% S.~Dagoret\\
% Del~Buono\\
% P.~Dingus\\
% H.~Duhm\\
% J.~Ebert\\
% S.~Eichenberger\\
% R.J.~Ellison\\
% Feltesse\\
% W.~Flauger\\
% A.~Fomenko\\
% G.~Franke\\
% J.~Garvey\\
% M.~Gennis\\
% L.~Goerlich\\
% P.~Goritchev\\
% H.~Greif\\
% E.M.~Hanlon\\
% R.~Haydar\\
% R.C.W.~Henderso\\
% P.~Hill\\
% H.~Hufnagel\\
% A.~Jacholkowska\\
% Johannsen\\
% S.~Kasarian\\
% I.R.~Kenyon\\
% C.~Kleinwort\\
% T.~K\"ohler\\
% S.D.~Kolya\\
% P.~Kostka\\
% U.~Kr\"uger\\
% J.~Kurzh\"ofer\\
% M.P.J.~Landon\\
% A.~Lebedev\\
% Ch.~Ley\\
% F.~Linsel\\
% H.~Lohmand\\
% Martin\\
% S.~Masson\\
% K.~Meier\\
% C.A.~Meyer\\
% S.~Mikocki\\
% J.V.~Morris\\
% B.~Naroska\\
% Nguyen\\
% U.~Obrock\\
% G.D.~Patel\\
% Ch.~Pichler\\
% S.~Prell\\
% F.~Raupach\\
% V.~Riech\\
% P.~Robmann\\
% N.~Sahlmann\\
% P.~Schleper\\
% Sch\"oning\\
% B.~Schwab\\
% A.~Semenov\\
% G.~Siegmon\\
% J.R.~Smith\\
% M.~Steenbock\\
% U.~Straumann\\
% C.~Thiebaux\\
% P.~Van~Esch\\
% from Yerevan Ph\\
% L.R.~West\\
% G.-G.~Winter\\
% T.P.~Yiou\\
% M.~Zimmer\end{multicols}
% %
% \section*{Sponsoring Institutions}
% %
% Bernauer-Budiman Inc., Reading, Mass.\\
% The Hofmann-International Company, San Louis Obispo, Cal.\\
% Kramer Industries, Heidelberg, Germany
% %
% \tableofcontents
% %
\mainmatter              % start of the contributions
%
\title{A Minimal Bidirectionally Typed \\Structure Editor}
%
%\titlerunning{Hamiltonian Mechanics}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Cyrus Omar\inst{1} \and Michael Hilton\inst{2} \and
Ian Voysey \and \\ Jonathan Aldrich? \and Matthew Hammer\inst{3} }
%
\authorrunning{Omar et al.} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
%\tocauthor{Ivar Ekeland, Roger Temam, Jeffrey Dean, David Grove,
%Craig Chambers, Kim B. Bruce, and Elisa Bertino}
%
\institute{Carnegie Mellon University, 
\email{comar@cs.cmu.edu}\\ 
%\texttt{http://www.cs.cmu.edu/\homedir comar/}
\and
(Michael's institutional information)
\and
(Matt's institutional information)}

\maketitle              % typeset the title of the contribution

\begin{abstract}
Programs (and proofs) are rich inductive structures, but  programmers typically construct and manipulate them only indirectly, through flat textual representations. This indirection  comes at a cognitive cost -- programmers must comprehend the many subtleties of textual syntax, and it can take several primitive text editor actions to make a single structural change. During these sequences of editor actions, code highlighters and various other assistive tools may be asked to reason about malformed program text, complicating their design.
%Unfortunately, this fact is somewhat obscure because  programmers typically construct and interact with  programs only indirectly, using a text editor composed with a parser. 
%There are some benefits to this approach, to be sure, but the structural mismatch between programs and text  also imposes a cognitive burden. 
%For example, the primitive edit actions available in a text editor (e.g. inserting or deleting a character or word)  do not always correspond to  sensible structural transformations. 
%Indeed, most structural  transformations require performing many primitive edit actions. 

\emph{Structure editors} promise to alleviate these burdens by exposing only edit actions that  correspond to  sensible structural  transformations. 
Existing designs for structure editors, however, are complex and somewhat \emph{ad hoc}. 
Our aim in this paper is to report on our ongoing efforts to develop a minimal type-theoretic account of a structure editor. 
Our system extends a standard bidirectionally typed lambda calculus with 
1) \emph{holes} (which stand for portions of the program that are under construction); 
%, which are identified by variables tracked in a separate linear \emph{hole context} 
2) a \emph{selection model}; and 3) an \emph{action model}. We then examine the essential metatheoretic properties that must be established about such a system. 
Finally, we outline our vision of a full-scale programming system designed ``from the ground up'' around the same fundamental concepts as this minimal formal system.

%\keywords{computational geometry, graph theory, Hamilton cycles}
\end{abstract}
%
\section{Introduction}
%
Programs (and, following the well-known Curry-Howard correspondence, proofs) are rich inductive structures. This fact is well understood amongst researchers and experienced programmers, but still perhaps  obscure amongst programmers at large because programmers typically construct and interact with  programs only indirectly, e.g. using a text editor composed with a parser. 

There are some benefits to this approach, to be sure, but the structural mismatch between programs and their textual representations  also imposes various burdens. 
For example, the primitive edit actions available in a text editor (e.g. inserting or deleting a character or word)  do not always correspond to  sensible structural transformations. 




\section{Holey Light}
Good name? :p
\subsection{Holes}
\begin{figure}
$\arraycolsep=4pt\begin{array}{lllllll}
\mathsf{HTyp} & \tau,\htau & ::= & 
  \tarr{\htau}{\htau} ~\vert~ 
  \tnum ~\vert~
  \tehole\\
\mathsf{HExp} & e,\hexp & ::= & 
  \hexp : \htau ~\vert~
  x ~\vert~ 
  \hlam{x}{\htau}{\hexp} ~\vert~ 
  \hap{\hexp}{\hexp} ~\vert~
  \hnum{n} ~\vert~
  \hadd{\hexp}{\hexp} ~\vert~
  \hehole ~\vert~
  \hhole{\hexp}
\end{array}$
%\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\caption{Syntax of types and expressions with holes. Empty holes are written $\hehole$ and non-empty holes are written $\hhole{\hexp}$. We use metavariables $\tau$ and $e$ rather than $\htau$ and $\hexp$ for \emph{complete} types and expressions, i.e. those with no sub-terms of hole form. Metavariable $x$ ranges over variables and $n$ over numerals.}
\label{fig:hexp-syntax}
\end{figure}

Typing contexts, $\hGamma$, are finite functions that map each variable $x \in \domof{\hGamma}$ to the hypothesis $x : \htau$. We use the metavariable $\Gamma$ for \emph{complete typing contexts}, i.e. typing contexts where each hypothesis mentions only complete types.

The judgements $\hana{\hGamma}{\hexp}{\htau}$, for type analysis, and $\hsyn{\hGamma}{\hexp}{\htau}$, for type synthesis, are defined mutually inductively by the following rules.

\begin{subequations}\label{rules:syn-ana}
Subsumption:
\begin{equation}\label{rule:ana-subsume}
\inferrule{
  \hsyn{\hGamma}{\hexp}{\htau'}\\
  \tsub{\htau'}{\htau}
}{
  \hana{\hGamma}{\hexp}{\htau}
}
\end{equation}
Subtyping coincides with syntactic equality for complete types. For incomplete types, the rules are given after we discuss holes below.

Ascription:
\begin{equation}\label{rule:syn-asc}
\inferrule{
  \hana{\hGamma}{\hexp}{\htau}
}{
  \hsyn{\hGamma}{\hexp : \htau}{\htau}
}
\end{equation}

Variable:
\begin{equation}\label{rule:syn-var}
\inferrule{ }{
  \hsyn{\hGamma, x : \htau}{x}{\htau}
}
\end{equation}

Lambda:
\begin{equation}\label{rule:syn-lam}
\inferrule{
  \hsyn{\hGamma, x : \htau_1}{\hexp}{\htau_2}
}{
  \hsyn{\hGamma}{\hlam{x}{\htau_1}{\hexp}}{\tarr{\htau_1}{\htau_2}}
}
\end{equation}

Application:
\begin{equation}\label{rule:syn-ap}
\inferrule{
  \hsyn{\hGamma}{\hexp_1}{\tarr{\htau_2}{\htau}}\\
  \hana{\hGamma}{\hexp_2}{\htau_2}
}{
  \hsyn{\hGamma}{\hap{\hexp_1}{\hexp_2}}{\htau}
}
\end{equation}

Number:
\begin{equation}\label{rule:syn-num}
\inferrule{ }{
  \hsyn{\hGamma}{\hnum{n}}{\tnum}
}
\end{equation}

Plus:
\begin{equation}\label{rule:syn-plus}
\inferrule{
  \hana{\hGamma}{\hexp_1}{\tnum}\\
  \hana{\hGamma}{\hexp_2}{\tnum}
}{
  \hsyn{\hGamma}{\hadd{\hexp_1}{\hexp_2}}{\tnum}
}
\end{equation}
Additional rules for holes.

Holes synthesize the hole type:
\begin{equation}\label{rule:syn-ehole}
\inferrule{ }{
  \hsyn{\hGamma}{\hehole}{\tehole}
}
\end{equation}
\begin{equation}\label{rule:syn-hole}
\inferrule{ }{
  \hsyn{\hGamma}{\hhole{\hexp}}{\tehole}
}
\end{equation}
\end{subequations}

Subtyping judgement $\tsub{\htau}{\htau'}$ is inductively defined by the following rules:
\begin{subequations}\label{rule:tsub-num}
\begin{equation}
\inferrule{ }{
  \tsub{\tnum}{\tnum}
}
\end{equation}
\begin{equation}\label{rule:tsub-arr}
\inferrule{
  \tsub{\htau_1'}{\htau_1}\\
  \tsub{\htau_2}{\htau_2'}
}{
  \tsub{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1'}{\htau_2'}}
}
\end{equation}
\begin{equation}\label{rule:tsub-hole}
\inferrule{ }{
  \tsub{\htau}{\tehole}
}
\end{equation}

\end{subequations}
\subsection{Selection Model}
\begin{figure}
\hspace{-3px}$\arraycolsep=3pt\begin{array}{lllllll}
\mathsf{ZTyp} & \ztau & ::= & 
  \zlsel{\htau} ~\vert~
  \zwsel{\htau} ~\vert~  
  \zrsel{\htau} ~\vert~
  \tarr{\ztau}{\htau} ~\vert~ 
  \tarr{\htau}{\ztau} \\
\mathsf{ZExp} & \zexp & ::= & 
  \zlsel{\hexp} ~\vert~
  \zwsel{\hexp} ~\vert~
  \zrsel{\hexp} ~\vert~
  \zexp : \htau ~\vert~
  \hexp : \ztau ~\vert~
  \hlam{x}{\ztau}{\hexp} ~\vert~
  \hlam{x}{\htau}{\zexp} ~\vert~
  \hap{\zexp}{\hexp} ~\vert~
  \hap{\hexp}{\zexp} ~\vert~
  \hadd{\zexp}{\hexp} ~\vert~
  \hadd{\hexp}{\zexp} ~\vert~
  \hhole{\zexp}
\end{array}$
%\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\caption{Syntax of zippered types and expressions, i.e. types and expressions with holes and a single contiguous selection.}
\label{fig:zexp-syntax}
\end{figure}

We write $\removeSel{\ztau}$ for the holey type constructed by removing the selection markers from the zippered type $\ztau$. This straightforward metafunction is defined as follows:
\begin{align*}
\removeSel{(\zlsel{\htau})} & = \htau\\
\removeSel{(\zwsel{\htau})} & = \htau\\
\removeSel{(\zrsel{\htau})} & = \htau\\
\removeSel{(\tarr{\ztau}{\htau})} & = \tarr{\removeSel{\ztau}}{\htau}\\
\removeSel{(\tarr{\htau}{\ztau})} & = \tarr{\htau}{\removeSel{\ztau}}
\end{align*}

Similarly, we write $\removeSel{\zexp}$ for the holey expression constructed by removing the selection markers from the zippered expression $\zexp$:
\begin{align*}
\removeSel{(\zlsel{\hexp})} & = \hexp\\
\removeSel{(\zwsel{\hexp})} & = \hexp\\
\removeSel{(\zrsel{\hexp})} & = \hexp\\
\removeSel{(\zexp : \htau)} & = \removeSel{\zexp} : \htau\\
\removeSel{(\hexp : \ztau)} & = \hexp : \removeSel{\ztau}\\
\removeSel{(\hlam{x}{\ztau}{\hexp})} & = \hlam{x}{\removeSel{\ztau}}{\hexp}\\
\removeSel{(\hlam{x}{\htau}{\zexp})} & = \hlam{x}{\htau}{\removeSel{\zexp}}\\
\removeSel{(\hap{\zexp}{\hexp})} & = \hap{\removeSel{\zexp}}{\hexp}\\
\removeSel{(\hap{\hexp}{\zexp})} & = \hap{\hexp}{\removeSel{\zexp}}\\
\removeSel{(\hadd{\zexp}{\hexp})} & = \hadd{\removeSel{\zexp}}{\hexp}\\
\removeSel{(\hadd{\hexp}{\zexp})} & = \hadd{\hexp}{\removeSel{\zexp}}\\
\removeSel{\hhole{\zexp}} &= \hhole{\removeSel{\zexp}}
\end{align*}

\subsection{Action Model}
\begin{figure}
\hspace{-3px}$\arraycolsep=3pt\begin{array}{llcllll}
\mathsf{Direction} & \delta & ::= & 
  \dLeft ~\vert~
  \dRight\\
\mathsf{Action} & \alpha & ::= & 
  \aMove{\delta} ~\vert~
  \aSelect{\delta} ~\vert~
  \aDel ~\vert~
  %\aReplace{\htau} ~\vert~
  %\aReplace{\hexp} ~\vert~
  \aExtend{\varphi}\\
\mathsf{Form} & \varphi & ::= & 
  \farr ~\vert~
  \fnum \\
& & \vert & 
  \fasc ~\vert~
  \fvar{x} ~\vert~
  \flam{x} ~\vert~
  \fap ~\vert~
  \fnumlit{n} ~\vert~
  \fplus ~\vert~
  \fhole
\end{array}$
%\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\caption{Syntax of actions.}
\label{fig:action-syntax}
\end{figure}
There are many ways to interact with a tree. 

\subsubsection{Relative Movement}

\subsubsection{Relative Selection}

\subsubsection{Deletion}

\subsubsection{Extension}

\subsection{Metatheory}
Action Determinism

Action Preservation

\subsubsection{Mechanization}
Agda proofs... explanation of basic approach and current status. (Ian)

\section{Implementation}
(Michael)

Reactive stream of actions -- reactive stream of zippered expressions -- reactive stream of views (string and web) (and then close the loop -- maybe make this a diagram?) 

Implementation in OCaml + jsoo + React. Link to GitHub. Explanation of current status.


\section{Related Work}
\subsection{Structure Editors}
Drag-and-drop / for novices: lots of examples, e.g. Alice and others

Contemporary: Lamdu, MPS/Mbeddr, TouchDevelop

Hybrid: Cyrus' active code completion paper

\subsection{Refactoring Models}
(Michael, can you fill this section out?)

\subsection{Formal Editor Models}
Need to do a search to see what else has been done...

\section{Discussion \& Conclusion}
\subsection{Future Work}
\begin{itemize}
\item More powerful language (codesigned and mechanized as we go along -- having a powerful editor might allow us to dispense with certain complex language features; give example of ad hoc polymorphism?)
\item Keyboard chords
\item Formal action suggestion and ranking models
\item Type-Specific Projections (ala TSLs)
\item Typed Documents
\item Collaboration (packaging system, diff algorithm, multiple cursors, etc.)
\end{itemize}

This work provides a foundation for studying all of these concepts independently -- show how they work with this system and it should be straightforward to scale to bigger system.

\begin{quote}
In any case, these are but steps toward more graphical program-description systems, for we will not forever stay confined to mere strings of symbols. 

--- Minsky, Turing Award lecture 
\end{quote}

%
% ---- Bibliography ----
%
% TODO
%\begin{thebibliography}{5}
%
%\end{thebibliography}
\end{document}
